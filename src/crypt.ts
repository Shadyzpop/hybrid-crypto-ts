import { pki, util, random, md, cipher } from 'node-forge';

import helpers from './helpers';
import { DEFAULT_MESSAGE_DIGEST, AES_STANDARD } from './consts';

interface CryptOptions {
    md: 'sha1' | 'sha256' | 'sha384' | 'sha512' | 'md5';
    entropy?: string | number;
}

interface CryptConstructorParams {
    md?: 'sha1' | 'sha256' | 'sha384' | 'sha512' | 'md5';
    entropy?: string | number;
}

interface SignatureType {
    signature: string;
    md: keyof typeof MessageDigestType;
    v?: string;
}

enum MessageDigestType {
    sha1 = 'sha1',
    sha256 = 'sha256',
    sha384 = 'sha384',
    sha512 = 'sha512',
    md5 = 'md5'
}

export class Crypt {
    private _options: CryptOptions = {
        md: DEFAULT_MESSAGE_DIGEST,
    }

    constructor(options?: CryptConstructorParams) {
        if (options) {
            this._options = {
                ...this._options,
                ...options
            };

            if (options.entropy) {
                this.entropy(options.entropy);
            }
        }
    }

    private getMessageDigest(messageDigest: MessageDigestType): md.MessageDigest {
        // failsafe
        if (!Object.values(MessageDigestType).includes(messageDigest)) {
            throw new Error('invalid argument passed to Message Digest');
        }
        return (md as any)[messageDigest.toString()].create();
    }

    private parseSignature(_signature: string): SignatureType {
		try {
			return JSON.parse(_signature);
		} catch (e) {
			return {
				signature: _signature,
				md: 'sha1',
				v: helpers.version(),
			};
		}
    }

    private validate(encrypted: string): void {
        const obj = JSON.parse(encrypted);
        const validProps = ['v', 'iv', 'keys', 'cipher'];
        if (!validProps.every((v) => v in obj)) {
            throw new Error('invalid encrypted');
        }
	}

    private fingerprint(publicKey: pki.PublicKey) {
		return pki.getPublicKeyFingerprint(publicKey, {
			encoding: 'hex',
			delimiter: ':',
		});
    }

    /**
     * Signs a payload in string format
     * @param privateKey private key in a string or pki format
     * @param message the payload to sign
     * @returns an object with the signature and its message digest type
     */
    public sign(privateKey: string | pki.PrivateKey, message: string) {
		const checkSum = this.getMessageDigest(MessageDigestType[this._options.md]);
		checkSum.update(message, 'utf8');


        if (!helpers.isPrivateKeyObject(privateKey)) {
            privateKey = pki.privateKeyFromPem(privateKey);
        }
        const signature = (privateKey as pki.rsa.PrivateKey).sign(checkSum);
        const signature64 = util.encode64(signature);

        return JSON.stringify({
            signature: signature64,
            md: this._options.md,
        });
    }

    /**
     * Verify that the decrypted payload and signature has been generated by the provided public key
     * @param publicKey public key in string or pki format
     * @param _signature the signature to verify in string format
     * @param decrypted the decrypted payload
     * @returns boolean
     */
    public verify(publicKey: string | pki.PublicKey, _signature: string, decrypted: string): boolean {
		if (!_signature) return false;

		// tslint:disable-next-line: prefer-const
		let { signature, md: _md } = this.parseSignature(_signature);

		const checkSum = this.getMessageDigest(MessageDigestType[_md]);
		checkSum.update(decrypted, 'utf8');

		signature = util.decode64(signature);

		if (typeof publicKey === 'string') {
			publicKey = pki.publicKeyFromPem(publicKey);
        }

		return (publicKey as pki.rsa.PublicKey).verify(checkSum.digest().getBytes(), signature);
    }

    /**
     * Encrypts a message into a payload
     * @param publicKeys public key/s in string or pki format
     * @param message the payload to encrypt in string format
     * @param signature the signature to include in the encrypted payload
     * @returns a stringified json object that represents the message provided in a payload format
     */
    public encrypt(publicKeys: string | pki.PublicKey | string[] | pki.PublicKey[], message: string, signature?: string) {
		publicKeys = helpers.toArray(publicKeys);

        publicKeys = (publicKeys as any[]).map((_key: string | pki.PublicKey) =>
            typeof _key === 'string' ? pki.publicKeyFromPem(_key) : _key
        );

		const iv = random.getBytesSync(32);
		const key = random.getBytesSync(32);

		const encryptedKeys = publicKeys.reduce((prevKeys, publicKey) => {
			const encryptedKey = (publicKey as pki.rsa.PublicKey).encrypt(key, 'RSA-OAEP');
            const fingerprint = this.fingerprint(publicKey);
            return {
                ...prevKeys,
                [fingerprint]: util.encode64(encryptedKey)
            };
		}, {});

		const buffer = util.createBuffer(message, 'utf8');
		const _cipher = cipher.createCipher(AES_STANDARD, key);

		_cipher.start({ iv });
		_cipher.update(buffer);
		_cipher.finish();

		const payload = {
            v: helpers.version(),
            iv: util.encode64(iv),
            keys: encryptedKeys,
            cipher: util.encode64(_cipher.output.data),
            signature,
        };

		return JSON.stringify(payload);
    }

    /**
     * Decrypts a payload into its original message format along with its metadata
     * @param privateKey private key in string or pki format
     * @param encrypted the payload in string format
     * @returns an object that has the decrypted message with the signature if provided in the encrypted payload
     */
    public decrypt(privateKey: string | pki.PrivateKey, encrypted: string) {
		this.validate(encrypted);

		const payload = JSON.parse(encrypted);

		if (typeof privateKey === 'string') {
			privateKey = pki.privateKeyFromPem(privateKey);
        }

		const fingerprint = this.fingerprint(privateKey as pki.PublicKey);
		const encryptedKey = payload.keys[fingerprint];

		if (!encryptedKey) {
			throw new Error('cannot decrypt, private key fingerprint is not included in the payload');
        }

		const keyBytes = util.decode64(encryptedKey);
		const iv = util.decode64(payload.iv);
		const _cipher = util.decode64(payload.cipher);

		const key = (privateKey as pki.rsa.PrivateKey).decrypt(keyBytes, 'RSA-OAEP');

		const buffer = util.createBuffer(_cipher);
		const decipher = cipher.createDecipher(AES_STANDARD, key);

		decipher.start({ iv });
		decipher.update(buffer);
		decipher.finish();

		const bytes = decipher.output.getBytes();
		const decrypted = util.decodeUtf8(bytes);
		return {
            message: decrypted,
            signature: payload.signature
        };
	}

    private entropy(input: string | number): void {
		const inputString = String(input);
		const bytes = util.encodeUtf8(inputString);

		random.collect(bytes);
	}
}